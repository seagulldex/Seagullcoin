require('dotenv').config();
const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const rateLimit = require('express-rate-limit');
const swaggerJsDoc = require('swagger-jsdoc');
const swaggerUi = require('swagger-ui-express');
const { NFTStorage, File } = require('nft.storage');
const xrpl = require('xrpl');
const { XummSdk } = require('xumm-sdk');
const fs = require('fs');
const path = require('path');

const app = express();
const port = process.env.PORT || 3000;

// CORS setup
app.use(cors({
  origin: ['https://bidds.com', 'https://xrp.cafe', 'https://outgoing-destiny-bladder.glitch.me'],
  credentials: true
}));

// Rate limiting (100 reqs per 15 minutes)
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: 'Too many requests, try again later.'
});
app.use(limiter);

// Body parsing
app.use(bodyParser.json({ limit: '10mb' }));
app.use(bodyParser.urlencoded({ extended: true }));

// Swagger setup
const swaggerOptions = {
  swaggerDefinition: {
    openapi: '3.0.0',
    info: {
      title: 'SGLCN-X20 Minting API',
      version: '1.0.0',
      description: 'API to mint NFTs using SeagullCoin on XRPL',
    },
    servers: [{ url: `https://outgoing-destiny-bladder.glitch.me` }]
  },
  apis: ['./server.js'],
};
const swaggerDocs = swaggerJsDoc(swaggerOptions);
app.use('/docs', swaggerUi.serve, swaggerUi.setup(swaggerDocs));

// XRPL + NFT.Storage + XUMM setup
const client = new xrpl.Client('wss://xrpl.ws');
const xumm = new XummSdk(process.env.XUMM_API_KEY);
const nftStorage = new NFTStorage({ token: process.env.NFT_STORAGE_KEY });

const SERVICE_WALLET = process.env.SERVICE_WALLET;
const SGLCN_ISSUER = process.env.SGLCN_ISSUER;
const SGLCN_HEX = process.env.SGLCN_HEX;
const SGLCN_COST = '0.5';

// Middleware to verify XUMM-authenticated user (used on gated endpoints)
async function verifyXummUser(req, res, next) {
  const { xummToken } = req.headers;
  if (!xummToken) return res.status(401).json({ error: 'Missing XUMM token' });

  try {
    const userData = await xumm.getUserToken(xummToken);
    req.wallet = userData?.sub;
    if (!req.wallet) throw new Error('Invalid token');
    next();
  } catch (e) {
    return res.status(403).json({ error: 'Unauthorized' });
  }
}

/**
 * @swagger
 * /pay:
 *   post:
 *     summary: Generate a XUMM payment payload to pay 0.5 SGLCN
 *     responses:
 *       200:
 *         description: Payment payload created
 */
app.post('/pay', async (req, res) => {
  try {
    const payload = await xumm.payload.create({
      txjson: {
        TransactionType: 'Payment',
        Destination: SERVICE_WALLET,
        Amount: {
          currency: SGLCN_HEX,
          issuer: SGLCN_ISSUER,
          value: SGLCN_COST
        }
      },
    });
    res.json({ uuid: payload.uuid, next: payload.next.always });
  } catch (err) {
    res.status(500).json({ error: 'Payment payload error', details: err.message });
  }
});

/**
 * @swagger
 * /mint:
 *   post:
 *     summary: Mint an NFT after verifying 0.5 SGLCN payment
 *     security:
 *       - xummAuth: []
 *     responses:
 *       200:
 *         description: NFT minted successfully
 */
app.post('/mint', verifyXummUser, async (req, res) => {
  const { name, description, imageBase64, domain, properties, collection } = req.body;
  if (!name || !imageBase64) return res.status(400).json({ error: 'Missing name or image' });

  try {
    const imageBuffer = Buffer.from(imageBase64, 'base64');
    const metadata = {
      name,
      description,
      image: new File([imageBuffer], 'image.png', { type: 'image/png' }),
      properties,
      collection,
      domain
    };
    const metadataCid = await nftStorage.store(metadata);
    const uriHex = Buffer.from(`ipfs://${metadataCid.url.split('ipfs://')[1]}`).toString('hex').toUpperCase();

    await client.connect();
    const wallet = xrpl.Wallet.fromSeed(process.env.SERVICE_SECRET);
    const tx = {
      TransactionType: 'NFTokenMint',
      Account: wallet.classicAddress,
      URI: uriHex,
      Flags: parseInt('8'), // Transferable
      NFTokenTaxon: 0
    };
    const prepared = await client.autofill(tx);
    const signed = wallet.sign(prepared);
    const result = await client.submitAndWait(signed.tx_blob);
    const nftId = result.result.meta.nftoken_id || null;
    await client.disconnect();
    res.json({ success: true, cid: metadataCid.url, nftId });
  } catch (e) {
    res.status(500).json({ error: 'Mint failed', details: e.message });
  }
});

/**
 * @swagger
 * /user:
 *   get:
 *     summary: Get connected XUMM wallet address
 *     security:
 *       - xummAuth: []
 *     responses:
 *       200:
 *         description: Wallet address
 */
app.get('/user', verifyXummUser, (req, res) => {
  res.json({ wallet: req.wallet });
});

// Start the server
app.listen(port, () => console.log(`âœ… API running at http://localhost:${port}`));
