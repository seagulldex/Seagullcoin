<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>User NFTs - SGLCN-X20</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="header.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    .pagination { margin-top: 20px; text-align: center; }
    .pagination button { margin: 0 5px; padding: 5px 10px; }
    #page-controls { margin: 15px 0; text-align: right; }
    .nft-card, .collection-card {
      border: 1px solid #ccc;
      border-radius: 10px;
      padding: 10px;
      text-align: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      cursor: pointer;
    }
    .nft-card img, .collection-card img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
    }
    .nft-grid, .collection-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 15px;
      padding: 15px 0;
    }
    .nft-card button { margin: 5px; }
    #back-btn { margin: 10px 0; display: none; }
    #search-bar {
      padding: 8px;
      font-size: 16px;
      width: 540px;
    }
    button {
      padding: 8px 12px;
      font-size: 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      border-radius: 4px;
    }
    button:hover {
      background-color: #45a049;
    }
    #timeframe-buttons {
      margin-bottom: 15px;
    }
    #timeframe-buttons button {
      margin-right: 8px;
      background-color: #2196F3;
      border-radius: 4px;
      color: white;
      border: none;
      cursor: pointer;
      padding: 6px 12px;
    }
    #timeframe-buttons button.active {
      background-color: #0b7dda;
    }
    #loading-spinner {
      text-align: center;
      margin-top: 30px;
    }
    #loading-spinner img {
      width: 80px;
      height: 80px;
    }
    #wallet-indicator.red {
      color: red;
      cursor: pointer;
    }
    #wallet-indicator.green {
      color: green;
      cursor: default;
    }
  </style>
</head>
<body>
  <div id="top-bar" style="display:flex; justify-content:space-between; align-items:center; padding:10px 20px; background:#eee;">
    <div><button id="logout-btn" style="display:none;">Logout</button></div>
    <div id="wallet-container">
      <div id="wallet-status">
        <span id="wallet-indicator" class="red">üî¥ Login</span>
      </div>
    </div>
  </div>

  <header>
    <nav>
      <ul style="display:flex; list-style:none; padding-left:0;">
        <li style="margin-right:15px;"><a href="index.html">Home</a></li>
        <li style="margin-right:15px;"><a href="stake.html">Stake</a></li>
        <li><a href="https://sglcn-x20-api.glitch.me/SeagullmansionsV2.html" target="_blank" rel="noopener noreferrer">SGLMN V2 (mint)</a></li>
      </ul>
    </nav>
  </header>

  <main style="padding: 20px;">
    <h1>Trading</h1>

    <h2>SGLCN/XRP Price Chart</h2>

    <div id="timeframe-buttons">
      <button data-timeframe="1h" class="active">1 Hour</button>
      <button data-timeframe="6h">6 Hours</button>
      <button data-timeframe="24h">24 Hours</button>
      <button data-timeframe="7d">7 Days</button>
    </div>

    <canvas id="priceChart" style="max-width: 700px; margin-bottom: 30px;"></canvas>

    <div id="loading-spinner" style="display:none;">
      <img src="https://media.giphy.com/media/U3qYN8S0j3bpK/giphy.gif" alt="Loading Seagull" class="seagull-spinner" />
      <p>Loading your NFTs...</p>
    </div>

    <button id="back-btn">‚Üê Back to Collections</button>

    <div id="nft-container" class="collection-grid" style="display:none;"></div>
    <div class="pagination" id="pagination" style="display:none;"></div>
  </main>

  <script>
    // Utilities
    function convertIPFSToURL(ipfsUrl) {
      if (!ipfsUrl) return "";
      return ipfsUrl.startsWith("ipfs://")
        ? "https://cloudflare-ipfs.com/ipfs/" + ipfsUrl.slice(7)
        : ipfsUrl;
    }

    // NFT Management
    let allNFTs = [];
    let collectionMap = {};
    let nftsPerPage = 50;
    let currentPage = 1;
    let currentNFTs = [];

    window.addEventListener('DOMContentLoaded', () => {
      updateWalletStatus();
      document.getElementById('back-btn').onclick = showCollections;
      setupTimeframeButtons();
    });

    function updateWalletStatus() {
      const wallet = localStorage.getItem('xumm_wallet_address');
      const indicator = document.getElementById('wallet-indicator');
      if (wallet) {
        indicator.textContent = 'üü¢ Connected';
        indicator.classList.remove('red');
        indicator.classList.add('green');
        indicator.title = 'Logged in';
        indicator.onclick = null;
        document.getElementById('logout-btn').style.display = 'inline-block';
        fetchNFTs(wallet);
      } else {
        indicator.textContent = 'üî¥ Login';
        indicator.classList.remove('green');
        indicator.classList.add('red');
        indicator.title = 'Click to login';
        indicator.onclick = startLoginFlow;
        document.getElementById('logout-btn').style.display = 'none';
        document.getElementById('nft-container').style.display = 'none';
        document.getElementById('pagination').style.display = 'none';
      }
    }

    async function startLoginFlow() {
      try {
        const res = await fetch('https://sglcn-x20-api.glitch.me/login');
        if (!res.ok) throw new Error('Login API error');
        const data = await res.json();
        window.open(data.payloadURL, "_blank");

        const interval = setInterval(async () => {
          const check = await fetch(`https://sglcn-x20-api.glitch.me/check-login?uuid=${data.payloadUUID}`);
          if (!check.ok) return;
          const loginStatus = await check.json();
          if (loginStatus.loggedIn) {
            clearInterval(interval);
            localStorage.setItem('xumm_wallet_address', loginStatus.account);
            updateWalletStatus();
          }
        }, 3000);
      } catch (err) {
        alert('Login failed. Please try again.');
        console.error(err);
      }
    }

    async function fetchNFTs(wallet) {
      document.getElementById('loading-spinner').style.display = 'block';
      document.getElementById('nft-container').style.display = 'none';
      document.getElementById('pagination').style.display = 'none';
      try {
        const res = await fetch(`https://sglcn-x20-api.glitch.me/catalog`);
        if (!res.ok) throw new Error('Failed to load NFT catalog');
        const data = await res.json();
        allNFTs = (data.nfts || []).filter(nft => nft.metadata && nft.metadata.name && nft.metadata.image);
        collectionMap = groupByCollection(allNFTs);
        showCollections();
      } catch (err) {
        alert('Error loading NFTs.');
        console.error(err);
      } finally {
        document.getElementById('loading-spinner').style.display = 'none';
      }
    }

    function groupByCollection(nfts) {
      const map = {};
      for (const nft of nfts) {
        const collection = (nft.metadata.collection && nft.metadata.collection.trim()) || 'Uncategorized';
        if (!map[collection]) map[collection] = [];
        map[collection].push(nft);
      }
      return map;
    }

    function showCollections() {
      document.getElementById('back-btn').style.display = 'none';
      const container = document.getElementById('nft-container');
      container.innerHTML = "";
      container.className = 'collection-grid';
      container.style.display = 'grid';
      for (const collection in collectionMap) {
        const colCard = document.createElement('div');
        colCard.className = 'collection-card';
        const sampleNFT = collectionMap[collection][0];
        let imgSrc = "";
        if (sampleNFT && sampleNFT.metadata && sampleNFT.metadata.image) {
          imgSrc = convertIPFSToURL(sampleNFT.metadata.image);
        }
        colCard.innerHTML = `
          <h3>${collection}</h3>
          <img src="${imgSrc}" alt="${collection} Icon" loading="lazy" />
          <p>${collectionMap[collection].length} NFTs</p>
        `;
        colCard.onclick = () => showNFTs(collection);
        container.appendChild(colCard);
      }
      document.getElementById('pagination').style.display = 'none';
    }

    function showNFTs(collection) {
      currentNFTs = collectionMap[collection] || [];
      currentPage = 1;
      document.getElementById('back-btn').style.display = 'inline-block';
      renderNFTPage();
    }

    function renderNFTPage() {
      const container = document.getElementById('nft-container');
      container.className = 'nft-grid';
      container.style.display = 'grid';

      const pagination = document.getElementById('pagination');
      pagination.style.display = 'block';
      pagination.innerHTML = '';

      const start = (currentPage - 1) * nftsPerPage;
      const end = start + nftsPerPage;
      const pageNFTs = currentNFTs.slice(start, end);

      container.innerHTML = '';
      pageNFTs.forEach(nft => {
        const nftCard = document.createElement('div');
        nftCard.className = 'nft-card';
        nftCard.innerHTML = `
          <h4>${nft.metadata.name || 'Unnamed NFT'}</h4>
          <img src="${convertIPFSToURL(nft.metadata.image)}" alt="${nft.metadata.name}" loading="lazy" />
          <p>${nft.metadata.description || ''}</p>
          <button onclick="alert('Transfer NFT functionality coming soon!')">Transfer</button>
        `;
        container.appendChild(nftCard);
      });

      // Pagination controls
      const totalPages = Math.ceil(currentNFTs.length / nftsPerPage);

      if (currentPage > 1) {
        const prevBtn = document.createElement('button');
        prevBtn.textContent = 'Prev';
        prevBtn.onclick = () => {
          currentPage--;
          renderNFTPage();
        };
        pagination.appendChild(prevBtn);
      }

      pagination.appendChild(document.createTextNode(` Page ${currentPage} of ${totalPages} `));

      if (currentPage < totalPages) {
        const nextBtn = document.createElement('button');
        nextBtn.textContent = 'Next';
        nextBtn.onclick = () => {
          currentPage++;
          renderNFTPage();
        };
        pagination.appendChild(nextBtn);
      }
    }

    // Chart.js Price Chart with Timeframe Buttons
    let priceChart;
    const ctx = document.getElementById('priceChart').getContext('2d');

    function setupTimeframeButtons() {
      const buttons = document.querySelectorAll('#timeframe-buttons button');
      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          buttons.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          fetchAndRenderPriceData(btn.dataset.timeframe);
        });
      });
      // Load default timeframe
      fetchAndRenderPriceData('1h');
    }

    async function fetchAndRenderPriceData(timeframe) {
      try {
        // Show loading text in canvas or disable chart temporarily
        if (priceChart) {
          priceChart.destroy();
        }
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.font = "16px Arial";
        ctx.fillText("Loading price data...", 10, 50);

        // Define start and end times for API call
        let startTime;
        const endTime = Date.now();
        switch (timeframe) {
          case '1h': startTime = endTime - 60 * 60 * 1000; break;
          case '6h': startTime = endTime - 6 * 60 * 60 * 1000; break;
          case '24h': startTime = endTime - 24 * 60 * 60 * 1000; break;
          case '7d': startTime = endTime - 7 * 24 * 60 * 60 * 1000; break;
          default: startTime = endTime - 60 * 60 * 1000;
        }

        // Use CoinGecko API to get price data for XRP (as a proxy)
        // SGLCN-X20 price is custom, so we use XRP as a placeholder
        const fromUnix = Math.floor(startTime / 1000);
        const toUnix = Math.floor(endTime / 1000);

        // CoinGecko API URL (using XRP as a proxy)
        const url = `https://api.coingecko.com/api/v3/coins/ripple/market_chart/range?vs_currency=xrp&from=${fromUnix}&to=${toUnix}`;
        // Note: vs_currency=xrp is invalid, so use 'usd' and treat as placeholder
        // We'll fetch in USD and just show the chart as example

        // Correction: CoinGecko does not support 'vs_currency=xrp', so fetch vs_currency=usd
        // Then just plot that price - for demo only.
        const correctedUrl = `https://api.coingecko.com/api/v3/coins/ripple/market_chart/range?vs_currency=usd&from=${fromUnix}&to=${toUnix}`;

        const res = await fetch(correctedUrl);
        if (!res.ok) throw new Error('Failed to fetch price data');
        const data = await res.json();

        // Data: prices array of [timestamp, price]
        const prices = data.prices || [];
        if (!prices.length) throw new Error('No price data available');

        // Prepare labels and price data
        const labels = prices.map(p => {
          const d = new Date(p[0]);
          if (timeframe === '7d') return d.toLocaleDateString();
          else if (timeframe === '24h' || timeframe === '6h') return d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
          else return d.toLocaleTimeString();
        });
        const priceValues = prices.map(p => p[1]);

        // Create Chart
        priceChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              label: 'XRP Price (USD)',
              data: priceValues,
              fill: false,
              borderColor: 'rgb(33, 150, 243)',
              tension: 0.1,
              pointRadius: 0,
            }]
          },
          options: {
            responsive: true,
            scales: {
              x: { display: true, title: { display: true, text: 'Time' } },
              y: { display: true, title: { display: true, text: 'Price (USD)' }, beginAtZero: false }
            },
            plugins: {
              legend: { display: true },
              tooltip: {
                mode: 'index',
                intersect: false,
              }
            },
            interaction: {
              mode: 'nearest',
              axis: 'x',
              intersect: false
            }
          }
        });
      } catch (err) {
        console.error(err);
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.font = "16px Arial";
        ctx.fillText("Failed to load price data.", 10, 50);
      }
    }
  </script>
</body>
</html>
